% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/extractLT.R
\name{extractLT}
\alias{extractLT}
\alias{extractLTpwr}
\title{Obtain complete set of LT or LD estimates}
\usage{
extractLT(
  p = 0.99,
  obj,
  link = "logit",
  logscale = FALSE,
  a = 1:3,
  b = 4:6,
  eps = 0,
  offset = 0,
  df.t = NULL
)

extractLTpwr(
  p = 0.99,
  obj,
  link = "fpower",
  logscale = FALSE,
  a = 1:3,
  b = 1:3,
  lambda = 0,
  eps = 0.015,
  offset = 0,
  df.t = NULL
)
}
\arguments{
\item{p}{Target mortality proportion.}

\item{obj}{\code{merMod} object, created using \code{lmer()} or
\code{glmerMod} object, created using \code{glmer()}.}

\item{link}{Link function, specified as a character string.
For a folded power function, specify \code{"fpower"}.}

\item{logscale}{Logical.  Specify \code{TRUE}, if LT values are
to be back-transformed from a logarithmic scale.}

\item{a}{Subscripts for intercepts.}

\item{b}{Subscripts for corresponding slopes.}

\item{eps}{Replace \code{prob} by \code{prob+eps} before transformation.}

\item{offset}{Use to undo scaling of time or dose variable. This is
passed to the \code{\link{fieller}} function that \code{extractLT}
calls.}

\item{df.t}{Degrees of freedom for variance-covariance matrix.
If not supplied, it will be calculated internally, using a
conservative (low) value.  One is using the \code{t} distribution as
an approximation.  Getting a good approximation is not straightforward.
See `vignette('introduction-mixed-models', package='afex')`, page 19.}

\item{lambda}{(\code{extractLTpwr} only) Power for power function.}
}
\value{
Matrix holding LD or LD estimates.
}
\description{
When supplied with a model object that has fitted
dose-response lines for each of several levels of a factor,
`extractLR` calls the function `fieller` to calculate lethal time
}
\details{
Fixed coefficients from `obj` must be for intercepts and
for slopes.  Starting the model formula with `0+` will commonly
do what is required. The coefficients `fixef(obj)[a]` are assumed
to specify line intercepts, while `fixef(obj)[b]` specify the
corresponding slopes.  These replace the arguments `nEsts`
(subscripts for intercepts were `1:nEsts`) and `slopeAdd`
(subscripts for slopes were `(nEsts+1):(nEsts+slopeAdd)`).
}
